采用模式1，16位定时器/计数器

![](.\img\uTools_1729355356126.png)

![](.\img\Snipaste_2024-10-20_00-33-17.png)

首先GATE后是一个非门，即将GATE的电平取反，后面就是一个或门，

所以当GATE置1时只有将INT0置1才可启动定时器，INT0属于外部中断，一般置0，当然也可以由外部中断来控制定时器的启停，就是将GATE置1

所以当没有外部晶振时一般都是将GATE置0，INT0置0；

或门后面是一个与门，所以**启用定时器的前提是TR0置1，**

SYSclk为系统晶振频率，每1.085计一次数，

计时器记一次数的时间即为机器周期

时钟周期=1/晶振频率，机器周期=12T x 时钟周期=12/晶振频率

机器周期 = 12/11.0592=1.085µs

所以及时一毫秒需要计数：1000/1.085=921

65535 - 921= 64614

64614 ÷ 256 = 252（高位）

64614 - 256 x 252 = 64614 - 64512 =102(低位)

所以每隔1µs就会产生一次中断，启动定时器时需要将TF0置零

```c
#include "REGX52.H"
/**
* @brief 定时器0初始化，1毫秒@11.0592MHz
* @param 无
* @retval 无
*/
void Timer0Init()		//1毫秒@11.0592MHz
{
	TMOD &= 0xF0;		//设置定时器模式
	TMOD |= 0x01;		//设置定时器模式，前四位是定时器0的配置，直接置零即可
	TL0 = 0x66;		//设置定时初值 102 
	TH0 = 0xFC;		//设置定时初值 252 
	TF0 = 0;		//清除TF0标志
	TR0 = 1;		//定时器0开始计时
      
    ET0 = 1;    //中断配置
    EA = 1;
    PT0 = 1;
}
/*
中断模板
void Timer0_Routine() interrupt 1{
    static unsigned int T0count;
    TH0 = 0xFC;//高位
    TL0 = 0x18;//低位
    T0count++;
    if(T0count >= 1000){T0count = 0;P2_0 = ~P2_0;}
}
*/

```

![](.\img\uTools_1729360708194.png)

如图所示Timer0的中断控制位为ET0 需置1，中断总控EA也需置1，PT0则用来控制中断优先级